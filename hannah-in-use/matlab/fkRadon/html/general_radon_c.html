<html><head><title>fkRadon - general_radon_c</title></head><body><table bgcolor="#e7ebf7" border=0 width="100%" cellpadding=0 cellspacing=0><tr><td>fkRadon reference pages</td><td align="right"><a href="radon_transform.html"><img src="prev.gif" alt="Previous page" border=0 align=bottom></a>&nbsp;<a href="fkRadon_product_page.html"><img src="up.gif" alt="Parent page" border=0 align=bottom></a>&nbsp;<a href="radon_optimal_theta.html"><img src="next.gif" alt="Next page" border=0 align=bottom></a></td></tr></table><h2>general_radon_c</h2>
<h3>synopsis</h3>
mex function for radon transform
<h3>syntax</h3><pre>
    r=GENERAL_RADON_C(theta,rho,m,dx,dy)
    r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp)
    r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method)
    r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method,constraint)
    r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method,constraint,valid)
    r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method,constraint,valid,rho_x)
</pre>
<h3>description</h3>
<p>
r=GENERAL_RADON_C(theta,rho,m,dx,dy) computes the radon transform of
matrix m with nearest neighbor interpolation for all lines defined by
all possible theta/rho pairs. Dx and dy are define the sample spacing
in the x (row) and y (column) dimensions.
</p>
<p>
r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp) if interp is 1 the radon
algorithm uses linear interpolation between the elements of matrix m.
</p>
<p>
r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method) chooses the method
to combine the matrix elements along a line. Possible values are:
0=integral, 1=sum, 2=mean, 3=slice, 4=product. If method is 'slice',
then theta and rho should be equal length vectors and a cell array is
returned with for each theta/rho pair the projection along the line.
</p>
<p>
r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method,constraint) if
constraint is 0 (default) then the algorithm will loop over the x
(row) dimension or y (column) dimension depending on the angle of the
line (e.g. for vertical lines, the algorithm should loop over the y
dimension, whereas for horizontal lines it should loop over the x
dimension). If constraint=1, then the algorithm will always loop over
the x (row) dimension; if constraint=2, the algorithm will always loop
over the y (column) dimension.
</p>
<p>
r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method,constraint,valid) if
valid=1, only those lines which span the complete width and/or height
of the matrix are considered.
</p>
<p>
r=GENERAL_RADON_C(theta,rho,m,dx,dy,interp,method,constraint,valid,rho_x)
if rho_x=1 then the values of rho are interpreted as the intercept
with the horizontal center line, rather than the distance from the
origin. This could be useful if you want rho to be in the same units
as the x dimension. Notice however, that in this mode, rho will go to
infinity if theta approaches +/- pi.
</p>


<table bgcolor="#e7ebf7" border=0 width="100%" cellpadding=0 cellspacing=0><tr valign=top><td align=left width="33%"><a href="radon_transform.html"><img src="prev.gif" alt="Previous page" border=0 align=bottom></a>&nbsp;&nbsp;radon_transform</td><td align=center width="34%"><a href="fkRadon_product_page.html"><img src="up.gif" alt="Parent page" border=0 align=bottom></a>&nbsp;&nbsp;Toolbox page</td><td align=right>radon_optimal_theta&nbsp;&nbsp;<a href="radon_optimal_theta.html"><img src="next.gif" alt="Next page" border=0 align=bottom></a></td></tr></table></body></html>